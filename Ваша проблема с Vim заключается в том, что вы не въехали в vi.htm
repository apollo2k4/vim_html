<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Ваша проблема с Vim заключается в том, что вы не въехали в vi</title>
<style>
body {
	font-family: Tahoma, Helvetica, sans-serif;
	font-size: 14px;
	/*color: #333;*/
	background: #fff;
}

h1,
h2,
h3,
h4,
h5,
h6 {
	line-height: 1em;
}

code,
kbd,
pre {
	font-family: "Lucida Console", Courier, monospace;
	background: #e7e7e7;
}

code,
kbd {
	padding: 1px 5px;
}

pre {
	padding: 5px;
	overflow-x: auto;
	word-wrap: normal;
}

pre code {
	padding: 0;
}

blockquote {
	border-left: 5px solid #e7e7e7;
	margin: 1em 0;
	padding-left: 10px;
}

hr {
	border: 0;
	border-top: 1px solid #e7e7e7;
}

table {
	border-collapse: collapse;
	border-spacing: 0;
}

table thead {
	border-bottom: 2px solid #e7e7e7;
}

table td,
table th {
	padding: 6px 13px;
	border: 1px solid #e7e7e7;
}

table th {
	font-weight: 700;
}

li p {
	margin: .5em 0;
}
</style>
<p>
<a href="https://web.archive.org/web/20230605031731/https://givi.olnd.ru/index.shtml">Курилка</a>
</p>
<div style="text-align: center; margin-bottom: 2em;">
  <p>
  Перевод с английского © <a href="https://web.archive.org/web/20230605031731/https://givi.olnd.ru/">Гиви Хакеридзе</a>.
  <a href="https://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim/1220118">Вопрос</a>
  и <a href="https://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim/1220118#1220118">ответ</a> на Stack Overflow.<br>
  См. также
  <a href="https://web.archive.org/web/20230605031731/https://givi.olnd.ru/vim-galore/vim-galore-ru.html">Vim-galore — по-русски</a>,
  <a href="https://web.archive.org/web/20230605031731/https://givi.olnd.ru/vim-galore/vim-for-php-programmers-ru.html">Vim для (PHP-)программистов</a>.
  </p>
</div>
<div style="margin-left: 4em; margin-right: 3em;">
<h2 style="text-align: center;">Каково ваше самое продуктивное клавиатурное сочетание в Vim?</h2>
<p>Я много слышал о <a href="http://www.vim.org/">Vim</a>, и «за», и «против».
И действительно, похоже, что с Vim вы можете (как разработчик) быть быстрее, чем с любым другим редактором.
Я использую Vim, чтобы делать самые простые вещи, но с Vim я более чем в 10 раз <em>менее продуктивен</em>.</p>
<p>Только о двух вещах следует заботиться, когда речь идёт о скорости (вас это может не сильно беспокоить, хотя должно бы):</p>
<ol>
<li>Попеременное использование левой и правой руки — <em>самый быстрый</em> способ использования клавиатуры.</li>
<li>Никогда не прикасаться к мыши — второй приём быть быстрым насколько 
это возможно.
Понадобится время, чтобы перенести руку, взять мышь, передвинуть её и 
вернуть руку обратно (к тому же, часто после этого приходится смотреть 
на клавиатуру, чтобы убедиться, что рука находится в нужном месте)</li>
</ol>
<p>Вот два примера, демонстрирующих, почему с Vim я менее продуктивен.</p>
<p><strong>Копирование/Вырезание и вставка.</strong>
Я делаю это постоянно.
Во всех современных редакторах, чтобы выделить текст, вы левой рукой нажимаете <kbd>Shift</kbd>, а правой перемещаете курсор.
Затем клавишами <kbd>Ctrl</kbd>+<kbd>C</kbd> копируете, после этого перемещаете курсор и при помощи <kbd>Ctrl</kbd>+<kbd>V</kbd> вставляете.</p>
<p>В Vim это просто ужасно:</p>
<ul>
<li><code>yy</code>, чтобы скопировать одну строку (практически никогда вам не понадобится целая строка!)</li>
<li><code>[число xx]yy</code>, чтобы скопировать в буфер <code>xx</code> строк.
Но вы никогда не знаете точно, выделили ли вы именно то, что хотели.
Мне часто приходится делать <code>[число xx]dd</code>, а затем <code>u</code> для отмены!</li>
</ul>
<p>Ещё пример?
<strong>Поиск и замена.</strong></p>
<ul>
<li>В <a href="https://ru.wikipedia.org/wiki/PSPad">PSPad</a>: <kbd>Ctrl</kbd>+<kbd>f</kbd>, напечатать то, что хотите найти, затем нажать <kbd>Enter</kbd>.</li>
<li>В Vim: <code>/</code>, напечатать то, что хотите найти, затем, если имеются специальные символы, поместить <code>\</code> перед <em>каждым</em> из них, и нажать <kbd>Enter</kbd>.</li>
</ul>
<p>И всё в Vim происходит похожим образом: видимо, я не понимаю, как с ним работать правильно.</p>
<p>NB : <strong><a href="http://www.viemu.com/vi-vim-cheat-sheet.gif">Шпаргалку</a> по <a href="https://web.archive.org/web/20230605031731/http://www.fprintf.net/vimCheatSheet.html">Vim</a> я уже изучил.</strong> :)</p>
<p>Вот мой вопрос:</p>
<p>Каким образом вы используете Vim так, что он делает вас более продуктивным, чем какой-нибудь современный редактор?</p>
<p style="text-align: right;">
<a href="https://web.archive.org/web/20230605031731/https://stackoverflow.com/users/106140">Jim Dennis</a>
</p>
<hr>
</div>
<h1 style="text-align: center;">Ваша проблема с Vim заключается в том, что вы не въехали в vi</h1>
<p>Вы упомянули вырезание при помощи <code>yy</code> и сетуете на то, 
что обычно вам не нужно вырезать целые строки.
Но на практике, программистам, редактирующим исходный код, очень часто 
приходится работать с целыми строками, диапазонами строк и блоками кода.
<code>yy</code> — только один из множества способов скопировать текст в анонимный буфер копирования (или «регистр», как это называется в <strong>vi</strong>).</p>
<p>«Цзен» <strong>vi</strong> — в том, что вы разговариваете на некоем языке.
Первое <code>y</code> — глагол.
Выражение <code>yy</code> — синоним <code>y_</code>.
<code>y</code> сдвоено для того, чтобы это было проще печатать, т.к. это очень часто встречающаяся операция.</p>
<p>Это же можно сделать при помощи <code>dd</code> <code>P</code> (удалить текущую строку и вставить её обратно; при этом, в качестве побочного эффекта, оставив её копию в анонимном регистре).
<code>y</code> и <code>d</code> — «сказуемые», которые в качестве «подлежащего» принимают любое перемещение. Таким образом, <code>yW</code> это — «скопировать отсюда (где курсор) до конца текущего/следующего (большого) слова», а <code>y'a</code> — «скопировать отсюда до строки, которая содержит метку '<em>a</em>'».</p>
<p>Если всё, что вы знаете, это только как перемещать курсор вверх, вниз, влево и вправо, то <strong>vi</strong>
 никогда не сделает вас продуктивнее, чем при использовании «Блокнота».
(Ну хорошо, у вас всё-таки будет подсветка синтаксиса и возможность 
работы с файлами большими, чем ничтожные ~45KB или что-то около того; но
 постойте, не уходите).</p>
<p>У <strong>vi</strong> есть 26 «меток» и 26 «регистров». В метке запоминается позиция курсора при помощи команды <code>m</code>.
Каждая метка обозначается одной буквой в нижнем регистре.
Команда <code>ma</code> устанавливает метку '<em>a</em>' в текущей позиции, а <code>mz</code> — метку '<em>z</em>'.
При помощи команды <code>'</code> (одиночная кавычка) можно переместиться к строке с меткой '<em>a</em>'.
Т.е., <code>'a</code> перемещает в начало строки, содержащей метку '<em>a</em>'.
Чтобы переместиться к точной позиции метки, можно использовать команду <code>`</code> (обратная кавычка).
Таким образом, <code>`z</code> переместит именно туда, где находится метка '<em>z</em>'.</p>
<p>Так как все они — перемещения, их можно использовать в качестве субъектов для «выражений».</p>
<p>Поэтому, одним из способов вырезать произвольную часть текста является установка метки. Обычно я использую '<em>a</em>' в качестве «первой» метки, а '<em>z</em>' — для следующей, и '<em>b</em>' для ещё одной и '<em>e</em>' в качестве пары (при использовании <strong>vi</strong>
 в течение 15 лет в интерактивном режиме, мне ни разу не понадобилось 
более четырёх меток; имеются некоторые соглашения для того, чтобы метки и
 содержимое регистров, создаваемые интерактивно, не нарушались макро).
После этого нужно перейти к другому концу интересуемого текста; не 
важно, в какую сторону.
Затем можно использовать просто <code>d`a</code>, чтобы вырезать, или <code>y`a</code>, чтобы скопировать.
Весь процесс требует 5 дополнительных нажатий клавиш (шесть, если начать в режиме «вставки», когда придётся нажать <code>Esc</code> для выхода в нормальный режим).
После вырезания или копирования вставка осуществляется одним нажатием: <code>p</code>.</p>
<p>Я говорю, что это один из способов вырезания или копирования текста. Однако, он — лишь один из многих.
Часто можно точно сказать, какая часть текста имеется в виду, не перемещая курсора и не выставляя меток.
Например, находясь внутри параграфа, можно для перемещения к его началу или концу использовать <code>{</code> и <code>}</code> соответственно.
Поэтому для перемещения параграфа я вырезаю его при помощи <code>{</code> <code>d}</code> (3 нажатия).
(Ну, а если так получилось, что я нахожусь в первой или последней строке параграфа, я могу использовать просто <code>d}</code> или <code>d{</code>.)</p>
<p>Значение слова «параграф» обычно интуитивно понятно. И оно схоже в применении, как к коду, так и к обычному тексту.</p>
<p>Часто бывает известен некий шаблон (регулярное выражение), который находится на другом конце интересующего нас текста.
Поиск вперёд или назад в терминах <strong>vi</strong> тоже является перемещением.
Поэтому в наших «выражениях» он также может быть использован в качестве «субъекта».
Поэтому я могу использовать <code>d/foo</code> для вырезания от текущей строки до строки ниже, которая содержит строку «foo», и <code>y?bar</code>,
 чтобы скопировать всё, начиная с текущей строки до ближайшей выше, 
содержащей «bar».
Если мне не нужно работать с целыми строками, я могу использовать 
перемещения поиска (как они есть), делать метки и выполнять команды <code>`x</code>, как это было описано выше.</p>
<p>Кроме «сказуемых» и «подлежащих» у <strong>vi</strong> есть «объекты» (в грамматическом смысле этого слова).
Ранее я говорил об использовании анонимного регистра.
Однако, у меня есть возможность использовать любой из «именованных» регистров, предваряя ссылку на «объект» при помощи <code>"</code> (модификатором «двойная кавычка»).
Таким образом, используя <code>"add</code>, я вырезаю в регистр '<em>a</em>' текущую строку, а при помощи <code>"by/foo</code> копирую текст в регистр '<em>b</em>' от текущего положения до строки, содержащей «foo».
Для вставки из регистра я просто предваряю команду вставки такой же модифицирующей последовательностью: <code>"ap</code> вставляет копию содержимого регистра '<em>a</em>' после позиции курсора, а  <code>"bP</code> вставляет копию из регистра '<em>b</em>' перед.</p>
<p>Такие «префиксы» добавляют понятия «прилагательное» и «наречие» к 
нашему «языку» управления текстом.
Большинство команд (глаголов) и перемещений (глаголов или объектов, в 
зависимости от контекста) могут воспринимать численные префиксы.
Например, <code>3J</code> означает «объединить со следующими тремя строками», а <code>d5}</code> — «удалить, начиная с текущей строки, пять параграфов ниже».</p>
<p>И всё это — лишь промежуточный уровень <strong>vi</strong>.
Здесь нет ничего специфичного для <strong>Vim</strong>, и нет более продвинутых приёмов <strong>vi</strong>,
 если вы готовы с ними познакомиться.
Если вы обладаете только этими приёмами среднего уровня, возможно, вам 
иногда пригодится написать кое-какие макро, потому что язык для 
манипуляции текстом достаточно лаконичен и выразителен для того, чтобы 
достаточно просто делать большинство работы при помощи «родного» языка.</p>
<hr>
<h3>Подборка более продвинутых трюков:</h3>
<p>Есть несколько <code>:</code>-команд, самая известная из которых — <code>:%s/foo/bar/g</code> — глобальная подстановка.
(Это, конечно, не настолько продвинутая, но другие команды, начинающиеся с <code>:</code>, могут таковыми оказаться).
Набор команд <code>:</code> <strong>vi</strong> унаследовал от <strong>ed</strong> (строчного редактора), а позднее — от набора утилит <strong>ex</strong> (расширенного строчного редактора).
На самом деле, <strong>vi</strong> был назван именно так за то, что он был визуальным интерфейсом для <strong>ex</strong>.</p>
<p>Обычно команды <code>:</code> работают со строками текста.
<strong>ed</strong> и <strong>ex</strong> были написаны в эпоху, когда 
экранные терминалы были редкостью, и большинство терминалов были 
устройствами типа «телетайп» (TTY).
Поэтому работа с напечатанной копией текста была в порядке вещей, при 
этом команды вводились через очень медленные устройства (обычная 
скорость соединения была 110 boud, примерно 11 символов в секунду, что 
медленнее, чем может напечатать достаточно быстрый наборщик; в 
многопользовательской среде были частыми сбои; и, кроме того, неплохо 
было бы экономить бумагу).</p>
<p>Вот поэтому синтаксис большинства команд <code>:</code> включает адрес или диапазон адресов (номеров строк), за которым следует сама команда.
Она принимает буквальные номера строк: <code>:127,215 s/foo/bar</code> для замены первого вхождения «foo» на «bar» в каждой строке с 127 по 215-ю.
Кроме этого, можно использовать сокращения типа <code>.</code> или <code>$</code> для текущей и последней строки соответственно.
Или относительные префиксы <code>+</code> и <code>-</code> для ссылки по смещению относительно текущей строки.
Таким образом, <code>:.,$j</code> означает «от текущей строки до последней, объединить все строки в одну».
Для <code>1,$</code> есть синоним <code>:%</code> (все строки).</p>
<p>Команды <code>:... g</code> и <code>:... v</code> дают дополнительное уточнение диапазону, т.к. они невероятно сильны.
<code>:... g</code> — префикс для «глобального» («globally») применения 
последующей команды ко всем строкам, которые соответствуют шаблону 
(регулярному выражению), а <code>:... v</code> применяет такую команду к строкам, которые шаблону НЕ соответствуют («v» из «conVerse» — <em>обратный</em>).
Как и в случае с другими командами <strong>ex</strong>, перед ними так же можно указать ссылки на адрес или диапазон.
Таким образом, <code>:.,+21g/foo/d</code> означает «удалить все строки, содержащие строку “foo”, начиная с текущей плюс следующие 21», в то время как <code>:.,$v/bar/d</code>  — отсюда до конца файла удалить строки, которые НЕ содержат строку “bar”».</p>
<p>Интересно, что создание распространённой команды Unix <strong>grep</strong> было вдохновлено этой командой <strong>ex</strong> (и названа <strong>grep</strong> в честь того, как была задокументирована <code>:g</code>).
Команда <strong>ex</strong> <code>:g/re/p</code> (grep) использовалась 
для пояснения способа, как глобально («globally») напечатать («print») 
строки, содержащие регулярное выражение («regular expression» (re)).
Когда использовались <strong>ed</strong> и <strong>ex</strong>, команда <code>:p</code> была одной из первых, которую любой изучал, и часто первой при редактировании любого файла.
Таким способом распечатывали текущее содержимое (обычно постранично при помощи <code>:.,25</code> или похожим способом).</p>
<p>Нужно отметить, что <code>:% g/.../d</code> или (его противоположность) <code>: v/.../d</code> — наиболее часто используемые шаблоны использования.
Однако существует ещё парочка команд <strong>ex</strong>, заслуживающие того, чтобы их запомнить:</p>
<p>Для перемещения строк можно использовать <code>m</code>, а для объединения — <code>j</code>.
Например, имеется некий список и нужно отделить всё, что соответствует 
(или, наоборот, не соответствует) некоторому шаблону, не удаляя строки 
совсем, тогда можно использовать что-то вроде: <code>:% g/foo/m$</code> ... и все строки, содержащие «foo», будут перенесены в конец файла.
(Обратите внимание на ещё один совет — использование конца файла в качестве рабочего пространства).
Это действие сохранит относительный порядок строк с «foo», переместив их в конец списка.
(Это эквивалентно примерно такому действию: <code>1G!GGmap!Ggrep foo&lt;ENTER&gt;1G:1,'a g/foo'/d</code> (скопировать весь файл в свой конец (ИМХО, вместо первого <code>!</code> д.б. <code>y</code> — <em>прим. пер.</em>), отфильтровать хвост файла при помощи grep и удалить ненужное с начала файла до метки <code>a</code> (ИМХО, кавычка в регулярном выражении — лишняя — <em>прим. пер.</em>)).</p>
<p>Для объединения строк я обычно нахожу шаблон для тех, которые нужно 
объединить с предшествующей (например, строки в маркированном списке, 
которые начинаются с «^ », но не с «^ * »).
В этом случае я делаю следующее: <code>:% g/^ /-1j</code> (для всех подходящих строк перейти выше на одну и объединить (ИМХО, шаблон будет совпадать и с «^ * » — <em>прим. пер.</em>)).

(BTW: в случае маркированного списка попытка поиска строк с маркой и 
объединения со следующей работать не будет по ряду причин ... это может 
объединить одну маркированную строку с другой, но не сможет объединить 
маркированную строку со <em>всеми</em> последующими; при сравнении он будет работать только попарно).</p>
<p>Можно было бы не упоминать, про то, что вместе с командами <code>g</code> и <code>v</code> (глобально/глобально-с-отрицанием) можно использовать нашего старого друга <code>s</code>
 (подстановку).
Редко бывает, когда это может понадобиться.
Однако рассмотрим некоторый пример, когда подстановку необходимо сделать
 в строках, которые соответствуют другому шаблону.
Бывает, приходится использовать сложные шаблоны с захватами и обратными 
ссылками для того, чтобы сохранить части строки, которые НЕ нужно 
изменять.
Но чаще проще отделить поиск от замены: <code>:% g/foo/s/bar/zzz/g</code> — для каждой строки, содержащей «foo», выполнить замену всех «bar» на «zzz».
(Нечто вроде <code>:% s/\(.*foo.*\)bar\(.*\)/\1zzz\2/g</code> будет 
работать только для тех вхождений «bar», которым ПРЕДШЕСТВУЕТ «foo» в 
той же строке; это и так выглядит достаточно неуклюже, но и потребует 
дополнительно усложнить выражение, чтобы отловить случаи, когда «bar» 
предшествует «foo».)</p>
<p>Дело ещё в том, что само наличие набора команд <strong>ex</strong> для <code>p</code>, <code>s</code> или <code>d</code> строк, это ещё не всё.</p>
<p>Адресами в <code>:</code> могут быть и метки.
То есть можно использовать <code>:'a,'bg/foo/j</code>, чтобы объединить строку, содержащую «foo», с последующей, если она находится между метками '<em>a</em>' и '<em>b</em>'.
(Да, конечно, во всех предшествующих примерах использования команд <strong>ex</strong> для ограничения набора строк файла можно использовать подобные выражения.)</p>
<p>Всё это достаточно туманно (за последние 15 лет я использовал 
подобное всего несколько раз).
Мне нетрудно признаться, что часто делаю вещи повторно и интерактивно, 
что, возможно это же можно было бы сделать более эффективно, если бы я 
потратил немного времени, чтобы придумать правильное заклинание.</p>
<p>Ещё одна очень полезная команда <strong>vi</strong> или <strong>ex</strong> — <code>r</code> для чтения содержимого другого файла.
То есть: <code>:r foo</code> вставляет содержимое файла с именем «foo» после текущей строки.</p>
<p>Ещё более мощная команда — <code>:r!</code>.
Она читает вывод команды.
Это то же самое, что приостановить сессию <strong>vi</strong>, выполнить команду, перенаправив её вывод в файл, возобновить сессию <strong>vi</strong> и прочитать содержимое временного файла.</p>
<p>И ещё более мощные команды: <code>!</code> (восклицательный знак — <em>бэнг</em>) и <code>:... !</code> (<strong>ex</strong> бэнг).
Они тоже выполняют внешние команды и читают результат в текущий файл.
Но кроме этого, они фильтруют порции нашего текста при помощи этой команды!
При помощи <code>1G!Gsort</code> можно отсортировать строки нашего текста (<code>G</code> — команда «goto» в <strong>vi</strong>;
 по умолчанию она переносит к концу файла, но, если перед ней указать 
номер строки, например, 1, она перенесёт к первой строке).</p>
<p>Это эквивалент варианта <strong>ex</strong> <code>:1,$!sort</code>.
Писатели часто используют <code>!</code> с утилитами Unix <strong>fmt</strong> или <strong>fold</strong> для переформатирования или «переноса по словам» порций текста.
Часто встречается макро <code>{!}fmt</code> (переформатирование текущего абзаца).
Программисты иногда используют их, что бы пропустить свой код или его часть через <strong>indent</strong> или другой инструмент для переформатирования.</p>
<p>Использование команд <code>:r!</code> и <code>!</code> означает, что любая внешняя утилита или фильтр может считаться расширением нашего редактора.
Я иногда использую это со скриптами, которые извлекают данные из базы данных, или с командами <strong>wget</strong> или <strong>lynx</strong>, которые получают данные с вебсайтов, или с командами <strong>ssh</strong>, которые получают данные с удалённых систем.</p>
<p>И ещё одна полезная команда <strong>ex</strong> — <code>:so</code> (сокращение от <code>:source</code>).
Она читает содержимое файла как серию команд.
При запуске обычно <strong>vi</strong> неявно выполняет <code>:source</code> с файлом <code>~/.exinitrc</code> (а <strong>Vim</strong>, конечно же, делает то же самое с <code>~/.vimrc</code>).
Полезность этого в том, что при помощи команды <code>:so</code> можно на лету изменить профиль редактора и настроить новый набор макро, аббревиатур и настроек.
Если вы достаточно сообразительны, то, сохранив последовательность команд <strong>ex</strong>, можно применять их к файлам, когда это потребуется.</p>
<p>Например, у меня есть семистрочный (36 символов) файл, который прогоняет файл через <strong>wc</strong> и вставляет в начале файла комментарий в стиле C с количеством слов.
Я могу применить такое «макро» к файлу при помощи командной строки <code>vim +'so mymacro.ex' ./mytarget</code> (опция <code>+</code> командной строки <strong>vi</strong> и <strong>Vim</strong>
 обычно используется для того, чтобы начать сессию редактирования в 
строке с определённым номером. Однако существует один малоизвестный 
факт, что за ней могут следовать любые допустимые команды или выражения <strong>ex</strong>, например, команда «source», что я здесь и проделал; в качестве простого примера, у меня есть скрипты, которые запускают <code>vi +'/foo/d|wq!' ~/.ssh/known_hosts</code> для неинтерактивного удаления элемента из моего файла известных хостов SSH, когда я пересматриваю набор серверов).</p>
<p>Обычно гораздо проще писать такие «макро» на Perl, AWK или <strong>sed</strong> (который, на самом деле, как и <strong>grep</strong> был создан под впечатлением от команды <strong>ed</strong>).</p>
<p>Возможно, самой непонятной командой <strong>vi</strong> будет команда <code>@</code>.
Нечасто выступая на курсах системных администраторов в течение 
ближайшего десятилетия, я встречал совсем немного людей, кто ей вообще 
пользуется.
<code>@</code> выполняет содержимое регистра, так, как если бы это была команда <strong>vi</strong> или <strong>ex</strong>.
Пример: я часто использую <code>:r!locate ...</code>, чтобы найти файл в моей системе и прочитать его название в мой документ.
Потом я удаляю всё ненужное, оставляя полный путь только того файла, который меня интересует.
Вместо кропотливых нажатий <kbd>Tab</kbd>, чтобы обойти каждый элемент пути (или, что ещё хуже, если бы мне довелось попасть на машину, где копия <strong>vi</strong> не имеет поддержки дополнения при помощи Tab), я просто использую:</p>
<ol>
<li><code>Oi:r</code> (для того, чтобы сделать текущую строку допустимой командой <strong>vi</strong>),</li>
<li><code>"cdd</code> (чтобы удалить строку в регистр «c») и</li>
<li><code>@c</code> выполняю эту команду.</li>
</ol>
<p>Всего 10 нажатий на клавиши (и выражение <code>"cdd</code> <code>@c</code> практически находится у меня на кончиках пальцев, поэтому я могу набрать его так же быстро, как и слово из шести букв).</p>
<hr>
<h3>Ободряющее замечание</h3>
<p>Я только притронулся к поверхности мощи <strong>vi</strong>, и ничего из того, о чём я здесь писал, не является частью «улучшений», за которые назван <strong>vim</strong>!
Всё, о чём я здесь говорил, должно работать в любой старой копии <strong>vi</strong>, и 20, и 30 лет назад.</p>
<p>Есть люди, которые используют мощь <strong>vi</strong> гораздо в большей степени, чем я когда-либо буду.</p>
<hr>
<p style="text-align: right;">
<a href="https://web.archive.org/web/20230605031731/https://stackoverflow.com/users/149076">Jim Dennis</a>,<br>
отредактировано 2011-12-22 11:43:37Z
</p>



<div id="automa-palette"></div></body><style class="stylus">body[class^="has-brand"][class*=" active-brand"][class*="fixed-header"] {
        padding-top: 0 !important;
        background-color: inherit !important
    }
    body[class^="has-brand"][class*=" active-brand"][class*="fixed-header"] > [id$="er"]:nth-child(-n+3) {
        width: unset !important
    }[data-video_status][data-adapter="vk"] .previewContainer {
        display: none !important
    }</style></html>
<!--
     FILE ARCHIVED ON 03:17:31 Jun 05, 2023 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 08:26:52 Jan 20, 2026.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 0.498
  exclusion.robots: 0.036
  exclusion.robots.policy: 0.027
  esindex: 0.009
  cdx.remote: 9.558
  LoadShardBlock: 100.22 (3)
  PetaboxLoader3.datanode: 90.749 (4)
  PetaboxLoader3.resolve: 76.746 (2)
  load_resource: 105.416
  nav: 0.132 (6)
-->